# C++ 构造函数详解

构造函数是 C++ 中一种特殊的成员函数，它在创建类对象时自动调用，用于初始化对象的数据成员。下面我将详细讲解构造函数的相关知识。

## 1. 构造函数的基本特点

1. **与类同名**：构造函数的名称必须与类名完全相同
2. **无返回类型**：构造函数不指定返回类型，甚至没有 `void`
3. **自动调用**：创建对象时自动调用
4. **可重载**：一个类可以有多个构造函数（重载）

## 2. 构造函数的类型

### 2.1 默认构造函数

```cpp
class MyClass {
public:
    MyClass() {  // 默认构造函数
        // 初始化代码
    }
};
```

- 不接受任何参数
- 如果没有定义任何构造函数，编译器会自动生成一个默认构造函数
- 如果定义了其他构造函数而没有定义默认构造函数，编译器不会自动生成默认构造函数

### 2.2 参数化构造函数

```cpp
class MyClass {
public:
    MyClass(int a, double b) {  // 参数化构造函数
        // 使用参数初始化成员
    }
};
```

- 接受一个或多个参数
- 用于根据提供的参数初始化对象

### 2.3 拷贝构造函数

```cpp
class MyClass {
public:
    MyClass(const MyClass& other) {  // 拷贝构造函数
        // 复制other的成员到当前对象
    }
};
```

- 接受一个同类型对象的常量引用作为参数
- 用于通过已有对象创建新对象
- 如果没有定义，编译器会自动生成一个执行浅拷贝的拷贝构造函数

## 3. 构造函数的初始化列表

```cpp
class MyClass {
    int a;
    double b;
    std::string s;
public:
    MyClass(int x, double y, const std::string& str) 
        : a(x), b(y), s(str) {  // 初始化列表
        // 构造函数体
    }
};
```

- 在构造函数参数列表后使用冒号(:)引入
- 比在构造函数体内赋值更高效
- 对于const成员和引用成员，必须使用初始化列表
- 初始化顺序由成员变量的声明顺序决定，而非初始化列表中的顺序

## 4. 委托构造函数 (C++11)

```cpp
class MyClass {
public:
    MyClass() : MyClass(0, 0.0) {}  // 委托给另一个构造函数
    MyClass(int a, double b) { /* ... */ }
};
```

- 一个构造函数可以调用同类的另一个构造函数
- 减少代码重复

## 5. 移动构造函数 (C++11)

```cpp
class MyClass {
public:
    MyClass(MyClass&& other) noexcept {  // 移动构造函数
        // 从other"窃取"资源
    }
};
```

- 接受一个右值引用参数
- 用于高效地从临时对象转移资源
- 通常标记为 `noexcept` 以支持标准库优化

## 6. 构造函数的使用示例

```cpp
class Person {
    std::string name;
    int age;
public:
    // 默认构造函数
    Person() : name("Unknown"), age(0) {}
    
    // 参数化构造函数
    Person(const std::string& n, int a) : name(n), age(a) {}
    
    // 拷贝构造函数
    Person(const Person& other) : name(other.name), age(other.age) {}
    
    // 移动构造函数
    Person(Person&& other) noexcept 
        : name(std::move(other.name)), age(other.age) {}
};

int main() {
    Person p1;                  // 调用默认构造函数
    Person p2("Alice", 25);     // 调用参数化构造函数
    Person p3 = p2;             // 调用拷贝构造函数
    Person p4 = std::move(p3);  // 调用移动构造函数
}
```

## 7. 注意事项

1. **隐式转换**：单参数构造函数可能会引起隐式转换，可用 `explicit` 关键字禁止
2. **虚构造函数**：构造函数不能是虚函数
3. **纯虚构造函数**：构造函数不能是纯虚函数
4. **继承中的构造函数**：派生类构造函数会先调用基类构造函数
5. **析构顺序**：构造顺序与析构顺序相反

构造函数是 C++ 面向对象编程的基础，合理使用各种构造函数可以提高代码的效率和安全性。
# C++构造函数详解 / Подробное объяснение конструкторов в C++

## 基本特点 / Основные характеристики

1. **与类同名** / **Имя совпадает с именем класса**
2. **无返回类型** / **Не имеет возвращаемого типа**
3. **自动调用** / **Вызывается автоматически**
4. **可重载** / **Может быть перегружен**

## 构造函数类型 / Типы конструкторов

### 默认构造函数 / Конструктор по умолчанию
```cpp
class MyClass {
public:
    MyClass() {  // 默认构造函数 / Конструктор по умолчанию
        // 初始化代码 / Код инициализации
    }
};
```

### 参数化构造函数 / Параметризированный конструктор
```cpp
class MyClass {
public:
    MyClass(int a, double b) {  // 参数化构造函数 / Параметризованный конструктор
        // 使用参数初始化成员 / Инициализация с параметрами
    }
};
```

### 拷贝构造函数 / Конструктор копирования
```cpp
class MyClass {
public:
    MyClass(const MyClass& other) {  // 拷贝构造函数 / Копирующий конструктор
        // 复制other的成员 / Копирование членов из other
    }
};
```

## 初始化列表 / Список инициализации
```cpp
class MyClass {
    int a;
    double b;
    std::string s;
public:
    MyClass(int x, double y, const std::string& str) 
        : a(x), b(y), s(str) {  // 初始化列表 / Список инициализации
        // 构造函数体 / Тело конструктора
    }
};
```

## 委托构造函数 (C++11) / Делегирующие конструкторы (C++11)
```cpp
class MyClass {
public:
    MyClass() : MyClass(0, 0.0) {}  // 委托给另一个构造函数 / Делегирование другому конструктору
    MyClass(int a, double b) { /* ... */ }
};
```

## 移动构造函数 (C++11) / Перемещающий конструктор (C++11)
```cpp
class MyClass {
public:
    MyClass(MyClass&& other) noexcept {  // 移动构造函数 / Перемещающий конструктор
        // 从other"窃取"资源 / "Перехват" ресурсов из other
    }
};
```

## 使用示例 / Пример использования
```cpp
class Person {
    std::string name;
    int age;
public:
    // 默认构造函数 / Конструктор по умолчанию
    Person() : name("Unknown"), age(0) {}  // "Неизвестно"
    
    // 参数化构造函数 / Параметризованный конструктор
    Person(const std::string& n, int a) : name(n), age(a) {}
    
    // 拷贝构造函数 / Конструктор копирования
    Person(const Person& other) : name(other.name), age(other.age) {}
    
    // 移动构造函数 / Перемещающий конструктор
    Person(Person&& other) noexcept 
        : name(std::move(other.name)), age(other.age) {}
};

int main() {
    Person p1;                  // 默认构造 / Конструктор по умолчанию
    Person p2("Alice", 25);     // 参数化构造 / Параметризованный конструктор
    Person p3 = p2;             // 拷贝构造 / Конструктор копирования
    Person p4 = std::move(p3);  // 移动构造 / Перемещающий конструктор
}
```

## 注意事项 / Важные замечания

1. **隐式转换** / **Неявные преобразования**:
   - 单参数构造函数可能会引起隐式转换 / Конструктор с одним параметром может вызывать неявные преобразования
   - 使用`explicit`禁止 / Используйте `explicit` для запрета

2. **虚构造函数** / **Виртуальные конструкторы**:
   - 构造函数不能是虚函数 / Конструктор не может быть виртуальной функцией

3. **继承中的构造函数** / **Конструкторы при наследовании**:
   - 派生类会先调用基类构造函数 / Конструктор производного класса сначала вызывает конструктор базового класса

4. **析构顺序** / **Порядок деструкции**:
   - 构造顺序与析构顺序相反 / Порядок конструкций противоположен порядку деструкций
